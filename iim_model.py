# -*- coding: utf-8 -*-
"""IIM model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aofFKS1ii7xL1k04cjSVDalLy0suy7zW
"""

import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import random

class IIM_Graph:
    def __init__(self):
        pass

    def create_graph(self, option, initial_type, steps, p=0.5):
        """
        Function to create the graph according to the provided option.
        - option: 1 for clone only, 2 for anticlone only, 3 for alternate clone/anticlone, 4 for probabilistic clone/anticlone
        - initial_type: 'a' for two connected vertices, 'b' for two disconnected vertices
        - steps: Number of iterations
        - p: Probability of cloning in option 4 (if applicable)
        """
        if initial_type == 'a':
            G = nx.Graph()
            G.add_edge("1", "2")  # Two connected vertices
        elif initial_type == 'b':
            G = nx.Graph()
            G.add_nodes_from(["1", "2"])  # Two disconnected vertices


        for step in range(steps):
            if option == 1:
                G = self.clone(G)
            elif option == 2:
                G = self.anticlone(G)
            elif option == 3:
                if step % 2 == 0:
                    G = self.clone(G)
                else:
                    G = self.anticlone(G)
            elif option == 4:
              G = self.probabilistic_copy(G)
                # if random.random() < p:
                #     G = self.clone(G)
                # else:
                #     G = self.anticlone(G)

        return G


    def clone(self, G):
        new_G = G.copy()
        vertices = list(G.nodes())
        for v in vertices:
            # Create the clone name by adding an extra apostrophe
            new_v = str(int(v) + len(vertices))
            #new_v = v + "'"
            new_G.add_node(new_v)
            for neighbor in G.neighbors(v):
                new_G.add_edge(new_v, neighbor)  # Connect new vertex to the neighborhood
            new_G.add_edge(v, new_v)  # Connect original vertex to its clone
        return new_G

    def anticlone(self, G):
        new_G = G.copy()
        vertices = list(G.nodes())
        for v in vertices:
            # Create the anticlone name by adding an extra apostrophe
            new_v = str(int(v) + len(vertices))
            #new_v = v + "'"
            new_G.add_node(new_v)
            # Anticlone means connecting to all vertices that are not neighbors of v (excluding v itself)
            anti_neighbors = set(G.nodes()) - set(G.neighbors(v)) - {v}
            for w in anti_neighbors:
                new_G.add_edge(new_v, w)
        return new_G

        #add the option 4 here
    def probabilistic_copy(self, G, p=0.5):
        new_G = G.copy()
        vertices = list(G.nodes())
        for v in vertices:
            # Create the clone name by adding an extra apostrophe
            new_v = str(int(v) + len(vertices))
            new_G.add_node(new_v)
            # With probability p we clone, and with probability 1-p we anticlone
            if random.random() < p: # clone
                for neighbor in G.neighbors(v):
                    new_G.add_edge(new_v, neighbor)  # Connect new vertex to the neighborhood
                new_G.add_edge(v, new_v)  # Connect original vertex to its clone
            else: # anticlone
                anti_neighbors = set(G.nodes()) - set(G.neighbors(v)) - {v}
                for w in anti_neighbors:
                    new_G.add_edge(new_v, w)
        return new_G

    def draw_graph(self, G, step, option, option_desc):
        pos = nx.spring_layout(G)
        nx.draw(G, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=500)
        plt.title(f"Step {step} - Option {option}: {option_desc}")
        plt.show()

        # Option descriptions
        option_descriptions = {
            1: "Cloning every vertex",
            2: "Anticloning every vertex",
            3: "Alternating between clone and anticloning",
            4: f"Probabilistic cloning (p={p}) and anticloning"
        }


    def calculate_diameter(self, G):
        if nx.is_connected(G):
            return nx.diameter(G)
        else:
            return "Graph is not connected, so the diameter is undefined."

    def compute_laplacian(self, G):
        """
        Function to calculate the normalized Laplacian L of the graph G.
        Also, visualizes the adjacency matrix A, degree matrix D, D^(-1/2), and the Laplacian L.
        """
        A = nx.adjacency_matrix(G).todense()  # Adjacency matrix A
        degrees = [d for _, d in G.degree()]
        D = np.diag(degrees)  # Diagonal degree matrix D

        # Compute D^(-1/2)
        D_inv_sqrt = np.diag([1/np.sqrt(d) if d > 0 else 0 for d in degrees])

        # Normalized Laplacian: L = I - D^(-1/2) * A * D^(-1/2)
        I = np.eye(len(G))  # Identity matrix
        L = I - D_inv_sqrt @ A @ D_inv_sqrt

        # Visualize matrices
        self.visualize_matrix(A, title="Adjacency Matrix A")
        self.visualize_matrix(D, title="Diagonal Degree Matrix D")
        self.visualize_matrix(D_inv_sqrt, title="D^(-1/2)")
        self.visualize_matrix(L, title="Normalized Laplacian L")

        return L

    def visualize_matrix(self, matrix, title):
        """
        Visualizes the matrix using seaborn heatmap.
        """
        plt.figure(figsize=(6, 6))
        sns.heatmap(matrix, annot=True, fmt=".2f", cmap='Blues', cbar=False)
        plt.title(title)
        plt.show()

    def calculate_spectral_gap(self, L):
        """
        Function to calculate the spectral gap of the normalized Laplacian matrix L.
        """
        eigenvalues = np.linalg.eigvalsh(L)
        lambda_1 = eigenvalues[1]  # Second smallest eigenvalue (λ1)
        lambda_n_minus_1 = eigenvalues[-1]  # Largest eigenvalue (λn-1)
        spectral_gap = max(abs(lambda_1 - 1), abs(lambda_n_minus_1 - 1))
        return spectral_gap

    def create_and_draw_steps(self, option, initial_type, p=0.5):
        """
        Function to create the graph with 4 iterations and visualize after each step.
        """
        if initial_type == 'a':
            G = nx.Graph([('1', '2')])  # Two connected vertices
        elif initial_type == 'b':
            G = nx.Graph()
            G.add_nodes_from(['1', '2'])  # Two disconnected vertices

        # Option descriptions
        option_descriptions = {
            1: "Cloning every vertex",
            2: "Anticloning every vertex",
            3: "Alternating between clone and anticloning",
            4: f"Probabilistic cloning (p={p}) and anticloning"
        }

        # Draw the initial graph (Step 0)
        self.draw_graph(G, step=0, option=option, option_desc=option_descriptions[option])

        # Iterations (steps 1 to 4)
        for step in range(1, 5):
            if option == 1:
                G = self.clone(G)
            elif option == 2:
                G = self.anticlone(G)
            elif option == 3:
                if step % 2 == 0:
                    G = self.clone(G)
                else:
                    G = self.anticlone(G)
            elif option == 4:
                G = self.probabilistic_copy(G)

            # Draw graph after each step
            self.draw_graph(G, step=step, option=option, option_desc=option_descriptions[option])

# Example usage in main code:
if __name__ == "__main__":
    iim = IIM_Graph()

    option = 4  # 1-4
    initial_type = 'a'  # 'a' or 'b'
    steps = 3  # Number of steps
    p = 0.6  # Probability for option 4

    G = iim.create_graph(option, initial_type, steps, p)

    iim.draw_graph(G, steps, option, p)

    # Calculate and visualize the Laplacian matrix
    L = iim.compute_laplacian(G)

    # Calculate and print the spectral gap
    spectral_gap = iim.calculate_spectral_gap(L)
    print(f"Spectral gap: {spectral_gap}")

    """
    # Create graph and visualize step-by-step process
    iim.create_and_draw_steps(option, initial_type, p)
    """


    """
    #Example usage to run 20 times and calculate the average spectral gap:
    spectral_gaps = []  # List to store spectral gaps
    for _ in range(20):  # Run the process 20 times
      G = iim.create_graph(option, initial_type, steps, p)
      L = iim.compute_laplacian(G)
      spectral_gap = iim.calculate_spectral_gap(L)
      spectral_gaps.append(spectral_gap)

    avg_spectral_gap = np.mean(spectral_gaps)  # Calculate the average spectral gap
    print(f"Average spectral gap over 20 runs: {avg_spectral_gap}")
    """

"""Draw steps"""

# Example usage in main code:
if __name__ == "__main__":
    ilm = IIM_Graph()

    option = 4  # 1-3
    initial_type = 'a'  # 'a' or 'b'
    p = 0.6  # Probability for option 4

    # Create graph and visualize step-by-step process
    ilm.create_and_draw_steps(option, initial_type, p)
